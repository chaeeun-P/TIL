# SQL_ADVANCED 7주차 정규 과제

## Week 7 : 정규 표현식 (REGEXP)

📌**SQL_ADVANCED 정규과제**는 매주 정해진 주제에 따라 **MySQL 공식 문서 또는 한글 블로그 자료를 참고해 개념을 정리한 후, 프로그래머스 SQL 문제 3문제**와 **추가 확인문제**를 직접 풀어보며 학습하는 과제입니다.

이번 주는 아래의 **SQL_ADVANCED_7th_TIL**에 나열된 주제를 중심으로 개념을 학습하고, 주차별 **학습 목표**에 맞게 정리해주세요. 정리한 내용은 GitHub에 업로드한 후, **스프레드시트의 ‘SQL’ 시트에 링크를 제출**해주세요.

**(수행 인증샷은 필수입니다.)**

> 프로그래머스 문제를 풀고 ‘정답입니다’ 문구를 캡쳐해서 올려주시면 됩니다.

**(마지막 주차입니다. 조금만 더 힘내주세요~!!!)**

## **SQL_ADVANCED_7th_TIL**

### 14.8.2 Regular Expressions

- **REGEXP/RLIKE 연산자와 REGEXP_LIKE(), REGEXP_REPLACE() 등 함수 사용법 및 정규표현식 패턴 문법을 학습하세요.**



## **🏁 강의 수강 (Study Schedule)**

| **주차** | **공부 범위**           | **완료 여부** |
| -------- | ----------------------- | ------------- |
| 1주차    | 서브쿼리 & CTE          | ✅             |
| 2주차    | 집합 연산자 & 그룹 함수 | ✅             |
| 3주차    | 윈도우 함수             | ✅             |
| 4주차    | Top N 쿼리              | ✅             |
| 5주차    | 계층형 질의 & 셀프 조인 | ✅             |
| 6주차    | PIVOT / UNPIVOT         | ✅             |
| 7주차    | 정규 표현식             | ✅             |

### 공식 문서 활용 팁

>  **MySQL 공식 문서는 영어로 제공되지만, 크롬 브라우저에서 공식 문서를 열고 이 페이지 번역하기에서 한국어를 선택하면 번역된 버전으로 확인할 수 있습니다. 다만, 번역본은 문맥이 어색한 부분이 종종 있으니 영어 원문과 한국어 번역본을 왔다 갔다 하며 확인하거나, 교육팀장의 정리 예시를 참고하셔도 괜찮습니다.**



# 1️⃣ 학습 내용

> 아래의 링크를 통해 *MySQL 공식문서*로 이동하실 수 있습니다.
>
> - 14.8.2 Regular Expressions : MySQL 공식문서 
>
> https://dev.mysql.com/doc/refman/8.0/en/regexp.html
>
> (한국어 버전)



<br>

---

# 2️⃣ 학습 내용 정리하기

## 1. 정규 표현식 REGEXP

```
✅ 학습 목표 :
* `REGEXP`, `REGEXP_LIKE` 등으로 문자열 패턴 검색을 수행할 수 있다.
* `^`, `$`, `[abc]`, `.` 등 기본적인 정규표현식 패턴을 이해하고 WHERE절에 활용할 수 있다.
* 데이터 정제 및 분류 조건을 문자열 기반으로 처리할 수 있다.
```

### 1. `REGEXP` 및 `REGEXP_LIKE()`를 사용한 문자열 패턴 검색

MySQL에서는 문자열이 복잡한 패턴과 일치하는지 확인하여 데이터를 필터링할 수 있음. 해당 기능은 `WHERE` 절에서 조건으로 가장 많이 활용됨.

* **패턴 일치 여부 확인 (필터링)을 수행:**
    * `expr **REGEXP** pat` 또는 `expr **RLIKE** pat` 구문을 사용하므로, `expr` 문자열이 `pat` 패턴과 일치하면 **1**, 아니면 **0**을 반환함. (두 연산자는 동의어임.)
    * `**REGEXP_LIKE**(expr, pat[, match_type])` 함수를 사용하므로 `REGEXP`와 동일한 기능을 수행할 수 있음. 여기에 추가 옵션(`match_type`)을 지정하므로 더 유연한 검색이 가능함.
    * `match_type` 옵션:
        * `c`: **Case-sensitive** (대소문자 구분)
        * `i`: **Case-insensitive** (대소문자 구분 안 함)
        * `m`: **Multiple-line** (여러 줄 모드 활성화)

***

### 2. `^`, `$`, `[abc]`, `.` 등 기본적인 정규표현식 패턴을 이해하고 `WHERE`절에 활용

`WHERE` 절에서 원하는 데이터를 정확하게 필터링하므로 검색 조건을 정교화할 수 있음. 이를 위해 다음 기본 패턴들을 숙지하고 `WHERE` 절에 적용하여 효율적인 데이터 조회가 가능함.

| 패턴 | 설명 | 활용 예시 (WHERE 절에 사용됨) |
| :--- | :--- | :--- |
| **`^`** | 문자열의 **시작** 매치 | `WHERE column REGEXP '^A'` (A로 시작하는 값 검색을 수행함) |
| **`$`** | 문자열의 **끝** 매치 | `WHERE column REGEXP 'Z$'` (Z로 끝나는 값 검색을 수행함) |
| **`.`** | **모든 단일 문자** 매치 (개행 문자 제외. `m` 옵션 시 개행 문자 포함) | `a.c` (a와 c 사이에 아무 문자 하나) |
| **`[abc]`** | **문자 클래스**: 괄호 안 문자 중 하나 매치 | `[0-9]`: 숫자 중 하나 매치 |
| **`[^abc]`** | **부정 문자 클래스**: 괄호 안 문자를 **제외**한 문자 매치 | `[^a-z]`: 소문자가 아닌 문자 매치 |
| **`*`** | 앞 요소 **0회 이상** 반복 | `Ba*n` (B, n 사이에 a가 없거나 여러 개) |
| **`+`** | 앞 요소 **1회 이상** 반복 | `Ba+n` (B, n 사이에 a가 최소 1개) |
| **`?`** | 앞 요소 **0회 또는 1회** | `Ba?n` (B, n 사이에 a가 없거나 1개) |
| **`|`** | **선택 (OR)** | `hello|world` (hello 또는 world 매치) |
| **`{n,m}`** | **반복 횟수** 지정 | `a{2,4}` (a가 2개에서 4개 반복) |
| **`\\`** | **특수 문자 이스케이프** | `1\\+2` (리터럴 `1+2`를 매치하기 위해 `+`를 이스케이프) |

* **활용 예시:**
    * `WHERE phone_num REGEXP '^[0-9]{3}-[0-9]{4}-[0-9]{4}$'` 구문을 사용, 정확히 '숫자 3개-숫자 4개-숫자 4개' 형태인 전화번호만 찾는 검색이 가능함.

***

### 3. 데이터 정제 및 분류 조건을 문자열 기반으로 처리 가능

단순 필터링을 넘어, 문자열에서 원하는 정보를 추출하거나 대체하므로 복잡한 데이터 처리 및 분류 조건을 문자열 기반으로 처리할 수 있음.

* `**REGEXP_SUBSTR**(expr, pat[, pos, occurrence, match_type])` 함수를 사용:
    * `expr`에서 **패턴(`pat`)과 일치하는 부분 문자열 자체**를 반환할 수 있음.
    * *예시:* 긴 로그 문자열에서 특정 에러 코드만 뽑아내는 추출 작업에 활용됨.
* `**REGEXP_REPLACE**(expr, pat, repl[, pos, occurrence, match_type])` 함수를 사용:
    * 패턴(`pat`)과 일치하는 부분을 **대체 문자열(`repl`)로 바꿔** 결과 문자열을 반환할 수 있음.
    * *예시:* 민감 정보(주민번호 등)를 패턴으로 찾아내서 `***` 같은 마스킹 문자로 대체하는 정제 작업에 활용됨.
* `**REGEXP_INSTR**(expr, pat[, pos, occurrence, return_option, match_type])` 함수를 사용:
    * 패턴(`pat`)이 처음 매치되는 **시작 인덱스(위치)**를 반환할 수 있음. (인덱스는 **1부터 시작**함.)
    * *예시:* 문자열 내에서 특정 키워드가 나타나는 위치를 확인하여 분류 기준을 세우는 데 활용됨.


<br>

---

# 3️⃣ 실습 문제

## 문제

- https://leetcode.com/problems/find-users-with-valid-e-mails/description/

> LeetCode 1517. Find Users With Valid E-mails
>
> 학습 포인트 : REGEXP를 활용한 이메일 유효성 검사 

- https://leetcode.com/problems/employees-with-missing-information/description/

> LeetCode 1965. Employees With Missing Information
>
> 학습 포인트 : REGEXP를 이용해 NULL 이 아닌 빈 문자열, 공백 등 이상값을 감지하기

**물론 REGEXP 없이 풀 수 있는 문제입니다. 하지만, 정규 표현식을 학습 한 만큼, 최대한 정규 표현식을 활용해서 문제를 풀어주세요**.

(아래는 그동안 배운 내용들을 토대로 풀어보세요.)

- https://school.programmers.co.kr/learn/courses/30/lessons/59413

> 입양 시각 구하기 (2)

- https://school.programmers.co.kr/learn/courses/30/lessons/299305

> 대장균들의 자식의 수 구하기

- https://school.programmers.co.kr/learn/courses/30/lessons/131534

> 상품을 구매한 회원 비율 구하기



---

## 문제 인증란

![images](/images/)
![images](/images/)
![images](/images/)
![images](/images/)
![images](/images/)

---

## 확인문제

### 문제 1

> **🧚희주는 고객의 이메일을 필터링하는 작업을 하고 있습니다. 모든 고객 중 이메일 도메인이 @gmail.com 또는 @naver.com인 고객만 추출하고자 합니다. REGEXP를 활용하여 쿼리를 작성해보세요.**

```
SELECT *
FROM customers
WHERE email REGEXP '(@gmail\\.com|@naver\\.com)$';
```

1. > 위 쿼리가 어떤 의미인지 설명하고, LIKE로 동일한 결과를 내는 방법도 함께 제시해보세요.
---
* REGEXP '...': email 컬럼의 문자열이 정규표현식 패턴과 일치하는지 확인

* @gmail\\\.com | @naver\\\.com: @gmail.com 또는 @naver.com 문자열을 찾음

* \\.: 마침표(.)를 정규표현식의 와일드카드(모든 문자)가 아닌 리터럴 마침표로 인식하도록 이스케이프

* |: OR 연산자 역할

* $: 문자열의 끝을 의미하여, 이메일이 반드시 해당 도메인으로 끝나야 함을 강제
~~~
SELECT *
FROM customers
WHERE email LIKE '%@gmail.com'
   OR email LIKE '%@naver.com';
~~~

2. > email이 빈 문자열이거나 NULL인 경우는 어떻게 처리해야 할지 고민해보세요.

`email` 컬럼의 값이 \*\*`NULL`\*\*이거나 \*\*빈 문자열 (`''`)\*\*인 경우, 해당 레코드는 유효한 이메일 도메인을 가질 수 없으므로 자동으로 필터링

| 경우 | `REGEXP`/`LIKE` 동작 | 처리 방법 |
| :---: | :---: | :--- |
| **`NULL`** | `REGEXP` 및 `LIKE` 연산 결과는 \*\*`NULL`\*\*이 되며, `WHERE` 절에서 `NULL`은 `FALSE`로 간주되어 **자동으로 제외** | 추가적인 처리는 필요 없음 |
| **빈 문자열 (`''`)** | 빈 문자열은 패턴으로 끝날 수 없으므로 `REGEXP` 및 `LIKE` 연산 결과가 \*\*`0` 또는 `FALSE`\*\*가 되어 **자동으로 제외** | 추가적인 처리는 필요 없음|


### 문제 2

> **🧚운영팀장인 지민이는 학회원 데이터에서 핸드폰 번호 형식을 점검하는 업무를 맡았습니다. 핸드폰 번호는 반드시 010으로 시작하고, 중간과 끝은 각각 4자리 숫자로 구성되어야 하며, 각 구간은 하이픈(-)으로 구분되어야 합니다. 예: 010-1234-5678 **
>
> **올바른 형식을 따르지 않는 번호를 가진 고객 목록을 찾아내기 위해 SQL의 REGEXP 기능을 사용하려고 합니다. 아래 조건에 맞는 고객 목록을 출력하는 쿼리를 작성해주세요.**

- 예시 테이블

| **student_id** | **name** | **phone_number** |
| -------------- | -------- | ---------------- |
| 1              | Anna     | 010-1234-5678    |
| 2              | Brian    | 011-1234-5678    |
| 3              | Cindy    | 01012345678      |
| 4              | David    | 010-123-5678     |
| 5              | Elsa     | 010-9999-8888    |

- 기대 출력 결과

| **student_id** | **name** | **phone_number** |
| -------------- | -------- | ---------------- |
| 2              | Brian    | 011-1234-5678    |
| 3              | Cindy    | 01012345678      |
| 4              | David    | 010-123-5678     |

> 문제 조건 
>
> - 형식이 **정확히** 010-XXXX-XXXX (X는 숫자, 총 4자리)인 경우만 통과
> - **정규 표현식을 사용하여 필터링**
> - 올바르지 않은 형식만 조회
> - 테이블 명은 Student로 해주세요.

~~~
SELECT
    student_id,
    name,
    phone_number
FROM
    Student
WHERE
    phone_number NOT REGEXP '^010-[0-9]{4}-[0-9]{4}$';
~~~





<!-- SQL ADVANCED 과제가 마무리되었습니다. 본 과정은 실제 SQLD 자격시험의 2과목 (고급 SQL 문법)을 기반으로 커리큘럼을 구성했습니다. 따라서 이번 과제를 성실히 수행한 분들은 SQLD 자격증 취득에 도전해보는 것을 추천드립니다. 추가적으로 이번 과제로 끝나는 것이 아니라, 앞으로도 다양한 문제를 풀어보며 배운 내용을 꾸준히 복습하고 응용해 나가는 것이 중요합니다. 또한, MySQL 외에도 PostgreSQL, Oracle, SQLite 등 다양한 SQL 엔진을 학습하는 것도 추천드립니다. 각각의 데이터베이스는 문법과 기능에 조금씩 차이가 있지만, 기본적인 SQL 개념을 이해하고 있다면 훨씬 쉽게 적용하고 이해할 수 있을 것입니다. 앞으로의 SQL 공부에도 화이팅이고, 부족한 템플릿이지만 끝까지 함께해주셔서 진심으로 감사합니다. -->

### **🎉 수고하셨습니다.**